/*
Copyright 2026.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// RoleDefinitionSpecApplyConfiguration represents a declarative configuration of the RoleDefinitionSpec type for use
// with apply.
//
// RoleDefinitionSpec defines the desired state of RoleDefinition.
type RoleDefinitionSpecApplyConfiguration struct {
	// TargetRole is the role type that will be reconciled. This can be a ClusterRole or a namespaced Role.
	TargetRole *string `json:"targetRole,omitempty"`
	// TargetName is the name of the target role. This can be any name that accurately describes the ClusterRole/Role.
	// Must be a valid Kubernetes name (max 63 characters for most resources).
	TargetName *string `json:"targetName,omitempty"`
	// TargetNamespace is the target namespace for the Role. Required when "TargetRole" is "Role".
	TargetNamespace *string `json:"targetNamespace,omitempty"`
	// ScopeNamespaced controls whether the API resource is namespaced or not. This can also be checked by
	// running `kubectl api-resources --namespaced=true/false`.
	ScopeNamespaced *bool `json:"scopeNamespaced,omitempty"`
	// RestrictedAPIs holds all API groups which will *NOT* be reconciled into the "TargetRole".
	// The RBAC operator discovers all API groups available and removes those which are defined here.
	// When Versions is empty (versions: []), all versions of that group are restricted.
	// When Versions is specified, only those API versions are excluded from resource discovery.
	// Note: Kubernetes RBAC PolicyRules are version-agnostic. If the same resource exists in
	// a non-restricted version of the same group, it will still appear in the generated role.
	RestrictedAPIs []v1.APIGroup `json:"restrictedApis,omitempty"`
	// RestrictedResources holds all resources which will *NOT* be reconciled into the "TargetRole".
	// The RBAC operator discovers all API resources available and removes those listed here.
	RestrictedResources []v1.APIResource `json:"restrictedResources,omitempty"`
	// RestrictedVerbs holds all verbs which will *NOT* be reconciled into the "TargetRole".
	// The RBAC operator discovers all resource verbs available and removes those listed here.
	RestrictedVerbs []string `json:"restrictedVerbs,omitempty"`
	// BreakglassAllowed marks generated ClusterRoles as eligible for temporary
	// privilege escalation via k8s-breakglass. When true, the generated role
	// receives the label t-caas.telekom.com/breakglass-compatible: "true".
	// Only applicable when TargetRole is ClusterRole. Defaults to false.
	BreakglassAllowed *bool `json:"breakglassAllowed,omitempty"`
}

// RoleDefinitionSpecApplyConfiguration constructs a declarative configuration of the RoleDefinitionSpec type for use with
// apply.
func RoleDefinitionSpec() *RoleDefinitionSpecApplyConfiguration {
	return &RoleDefinitionSpecApplyConfiguration{}
}

// WithTargetRole sets the TargetRole field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the TargetRole field is set to the value of the last call.
func (b *RoleDefinitionSpecApplyConfiguration) WithTargetRole(value string) *RoleDefinitionSpecApplyConfiguration {
	b.TargetRole = &value
	return b
}

// WithTargetName sets the TargetName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the TargetName field is set to the value of the last call.
func (b *RoleDefinitionSpecApplyConfiguration) WithTargetName(value string) *RoleDefinitionSpecApplyConfiguration {
	b.TargetName = &value
	return b
}

// WithTargetNamespace sets the TargetNamespace field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the TargetNamespace field is set to the value of the last call.
func (b *RoleDefinitionSpecApplyConfiguration) WithTargetNamespace(value string) *RoleDefinitionSpecApplyConfiguration {
	b.TargetNamespace = &value
	return b
}

// WithScopeNamespaced sets the ScopeNamespaced field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ScopeNamespaced field is set to the value of the last call.
func (b *RoleDefinitionSpecApplyConfiguration) WithScopeNamespaced(value bool) *RoleDefinitionSpecApplyConfiguration {
	b.ScopeNamespaced = &value
	return b
}

// WithRestrictedAPIs adds the given value to the RestrictedAPIs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the RestrictedAPIs field.
func (b *RoleDefinitionSpecApplyConfiguration) WithRestrictedAPIs(values ...v1.APIGroup) *RoleDefinitionSpecApplyConfiguration {
	for i := range values {
		b.RestrictedAPIs = append(b.RestrictedAPIs, values[i])
	}
	return b
}

// WithRestrictedResources adds the given value to the RestrictedResources field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the RestrictedResources field.
func (b *RoleDefinitionSpecApplyConfiguration) WithRestrictedResources(values ...v1.APIResource) *RoleDefinitionSpecApplyConfiguration {
	for i := range values {
		b.RestrictedResources = append(b.RestrictedResources, values[i])
	}
	return b
}

// WithRestrictedVerbs adds the given value to the RestrictedVerbs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the RestrictedVerbs field.
func (b *RoleDefinitionSpecApplyConfiguration) WithRestrictedVerbs(values ...string) *RoleDefinitionSpecApplyConfiguration {
	for i := range values {
		b.RestrictedVerbs = append(b.RestrictedVerbs, values[i])
	}
	return b
}

// WithBreakglassAllowed sets the BreakglassAllowed field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the BreakglassAllowed field is set to the value of the last call.
func (b *RoleDefinitionSpecApplyConfiguration) WithBreakglassAllowed(value bool) *RoleDefinitionSpecApplyConfiguration {
	b.BreakglassAllowed = &value
	return b
}
