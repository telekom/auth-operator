# SPDX-FileCopyrightText: 2026 Deutsche Telekom AG
#
# SPDX-License-Identifier: Apache-2.0

name: Cleanup PR Packages

on:
  schedule:
    # Run daily at 3:00 AM UTC
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (do not delete packages)'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: read
  packages: write
  pull-requests: read

env:
  REGISTRY: ghcr.io

jobs:
  cleanup-container-images:
    name: Cleanup PR Container Images
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Get closed PR numbers
        id: closed-prs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get all closed PRs from the last 90 days
          CLOSED_PRS=$(gh pr list --state closed --limit 500 --json number --jq '.[].number' | tr '\n' ' ')
          echo "closed_prs=${CLOSED_PRS}" >> $GITHUB_OUTPUT
          echo "Found closed PRs: ${CLOSED_PRS}"

      - name: List and cleanup PR container images
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ inputs.dry_run || 'false' }}
        run: |
          set -euo pipefail
          
          PACKAGE_NAME="auth-operator"
          OWNER="${{ github.repository_owner }}"
          
          echo "Fetching container image versions for ${PACKAGE_NAME}..."
          
          # Get all package versions
          VERSIONS=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/orgs/${OWNER}/packages/container/${PACKAGE_NAME}/versions" \
            --paginate \
            --jq '.[] | select(.metadata.container.tags[] | test("^pr-[0-9]+")) | {id: .id, tags: .metadata.container.tags}' 2>/dev/null || echo "")
          
          if [ -z "$VERSIONS" ]; then
            echo "No PR container images found."
            exit 0
          fi
          
          echo "Found PR container images:"
          echo "$VERSIONS" | jq -c '.'
          
          # Process each PR image
          echo "$VERSIONS" | jq -c '.' | while read -r version; do
            VERSION_ID=$(echo "$version" | jq -r '.id')
            ALL_TAGS=$(echo "$version" | jq -r '.tags | join(",")')
            
            # Find the PR tag from all tags (format: pr-<number> or pr-<number>-<sha>)
            PR_TAG=$(echo "$version" | jq -r '.tags[]' | grep -E '^pr-[0-9]+' | head -1 || echo "")
            
            if [ -z "$PR_TAG" ]; then
              echo "No PR tag found in tags: $ALL_TAGS"
              continue
            fi
            
            # Extract PR number from tag (handles both pr-42 and pr-42-abc1234)
            PR_NUM=$(echo "$PR_TAG" | sed -n 's/^pr-\([0-9]*\).*/\1/p')
            
            if [ -z "$PR_NUM" ]; then
              echo "Could not extract PR number from tag: $PR_TAG"
              continue
            fi
            
            # Check if PR is closed
            PR_STATE=$(gh pr view "$PR_NUM" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")
            
            if [ "$PR_STATE" = "CLOSED" ] || [ "$PR_STATE" = "MERGED" ]; then
              echo "PR #${PR_NUM} is ${PR_STATE}, cleaning up image version ${VERSION_ID} with tags: ${ALL_TAGS}"
              
              if [ "$DRY_RUN" = "true" ]; then
                echo "[DRY RUN] Would delete version ${VERSION_ID}"
              else
                gh api \
                  --method DELETE \
                  -H "Accept: application/vnd.github+json" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  "/orgs/${OWNER}/packages/container/${PACKAGE_NAME}/versions/${VERSION_ID}" \
                  && echo "Deleted version ${VERSION_ID}" \
                  || echo "Failed to delete version ${VERSION_ID}"
              fi
            else
              echo "PR #${PR_NUM} is ${PR_STATE}, keeping image version ${VERSION_ID}"
            fi
          done
          
          echo "Container image cleanup complete."
          
          # Cleanup untagged images — but preserve digests referenced by tagged
          # manifest lists (multi-arch builds push per-arch images by digest only;
          # deleting them breaks the parent manifest list).
          echo ""
          echo "Building protected digest set from tagged manifests..."
          PROTECTED=$(mktemp)
          
          # Obtain a read-only OCI token for manifest inspection
          OCI_TOKEN=$(curl -sf \
            -u "token:${GH_TOKEN}" \
            "https://ghcr.io/token?service=ghcr.io&scope=repository:${OWNER,,}/${PACKAGE_NAME}:pull" \
            | jq -r '.token') || true
          
          if [ -z "${OCI_TOKEN}" ] || [ "${OCI_TOKEN}" = "null" ]; then
            echo "WARNING: Could not obtain OCI token — skipping untagged cleanup to avoid breaking manifest lists."
          else
            # Collect digests of all tagged versions
            TAGGED_DIGESTS=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/orgs/${OWNER}/packages/container/${PACKAGE_NAME}/versions" \
              --paginate \
              --jq '.[] | select(.metadata.container.tags | length > 0) | .name' 2>/dev/null || echo "")
            
            # For each tagged manifest, resolve child digests (level 1)
            for DIGEST in $TAGGED_DIGESTS; do
              MANIFEST=$(curl -sf \
                -H "Authorization: Bearer ${OCI_TOKEN}" \
                -H "Accept: application/vnd.oci.image.index.v1+json,application/vnd.docker.distribution.manifest.list.v2+json" \
                "https://ghcr.io/v2/${OWNER,,}/${PACKAGE_NAME}/manifests/${DIGEST}" 2>/dev/null) || continue
              echo "$MANIFEST" | jq -r '(.manifests // [])[]?.digest // empty' >> "$PROTECTED" 2>/dev/null || true
            done
            
            # Level 2: children of children (nested indices with attestations/provenance)
            if [ -s "$PROTECTED" ]; then
              for DIGEST in $(sort -u "$PROTECTED"); do
                MANIFEST=$(curl -sf \
                  -H "Authorization: Bearer ${OCI_TOKEN}" \
                  -H "Accept: application/vnd.oci.image.index.v1+json,application/vnd.docker.distribution.manifest.list.v2+json,application/vnd.oci.image.manifest.v1+json,application/vnd.docker.distribution.manifest.v2+json" \
                  "https://ghcr.io/v2/${OWNER,,}/${PACKAGE_NAME}/manifests/${DIGEST}" 2>/dev/null) || continue
                echo "$MANIFEST" | jq -r '(.manifests // [])[]?.digest // empty' >> "$PROTECTED" 2>/dev/null || true
              done
            fi
            
            sort -u -o "$PROTECTED" "$PROTECTED"
            PROTECTED_COUNT=$(wc -l < "$PROTECTED" | tr -d ' ')
            echo "Found ${PROTECTED_COUNT} protected digests referenced by tagged manifests"
            
            # Now delete only truly orphaned untagged versions
            echo ""
            echo "Fetching untagged container images..."
            UNTAGGED=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/orgs/${OWNER}/packages/container/${PACKAGE_NAME}/versions" \
              --paginate \
              --jq '.[] | select(.metadata.container.tags | length == 0) | "\(.id) \(.name)"' 2>/dev/null || echo "")
            
            if [ -z "$UNTAGGED" ]; then
              echo "No untagged container images found."
            else
              DELETED=0
              KEPT=0
              while read -r VERSION_ID VERSION_NAME; do
                if [ -z "$VERSION_ID" ]; then
                  continue
                fi
                if grep -qF "$VERSION_NAME" "$PROTECTED" 2>/dev/null; then
                  echo "Keeping ${VERSION_NAME} (referenced by tagged manifest)"
                  KEPT=$((KEPT + 1))
                  continue
                fi
                echo "Deleting orphaned ${VERSION_NAME} (id: ${VERSION_ID})"
                if [ "$DRY_RUN" = "true" ]; then
                  echo "[DRY RUN] Would delete untagged version ${VERSION_ID}"
                else
                  gh api \
                    --method DELETE \
                    -H "Accept: application/vnd.github+json" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    "/orgs/${OWNER}/packages/container/${PACKAGE_NAME}/versions/${VERSION_ID}" \
                    && echo "Deleted untagged version ${VERSION_ID}" \
                    || echo "Failed to delete untagged version ${VERSION_ID}"
                fi
                DELETED=$((DELETED + 1))
              done <<< "$UNTAGGED"
              echo "Untagged image cleanup complete. Deleted: ${DELETED}, Kept (protected): ${KEPT}"
            fi
          fi
          
          rm -f "$PROTECTED"

  cleanup-helm-charts:
    name: Cleanup PR Helm Charts
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: List and cleanup PR Helm charts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ inputs.dry_run || 'false' }}
        run: |
          set -euo pipefail
          
          PACKAGE_NAME="auth-operator"
          OWNER="${{ github.repository_owner }}"
          
          echo "Fetching Helm chart versions for ${PACKAGE_NAME}..."
          
          # Get all package versions for Helm charts
          # Helm charts are stored under the 'charts' package in the org
          VERSIONS=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/orgs/${OWNER}/packages/container/charts%2F${PACKAGE_NAME}/versions" \
            --paginate \
            --jq '.[] | select(.metadata.container.tags[] | test("^0\\.0\\.0-pr[0-9]+")) | {id: .id, tags: .metadata.container.tags}' 2>/dev/null || echo "")
          
          if [ -z "$VERSIONS" ]; then
            echo "No PR Helm charts found."
            exit 0
          fi
          
          echo "Found PR Helm charts:"
          echo "$VERSIONS" | jq -c '.'
          
          # Process each PR chart
          echo "$VERSIONS" | jq -c '.' | while read -r version; do
            VERSION_ID=$(echo "$version" | jq -r '.id')
            ALL_TAGS=$(echo "$version" | jq -r '.tags | join(",")')
            
            # Find the PR tag from all tags (format: 0.0.0-pr<number> or 0.0.0-pr<number>.<sha>)
            PR_TAG=$(echo "$version" | jq -r '.tags[]' | grep -E '^0\.0\.0-pr[0-9]+' | head -1 || echo "")
            
            if [ -z "$PR_TAG" ]; then
              echo "No PR tag found in tags: $ALL_TAGS"
              continue
            fi
            
            # Extract PR number from tag (handles both 0.0.0-pr42 and 0.0.0-pr42.abc1234)
            PR_NUM=$(echo "$PR_TAG" | sed -n 's/^0\.0\.0-pr\([0-9]*\).*/\1/p')
            
            if [ -z "$PR_NUM" ]; then
              echo "Could not extract PR number from tag: $PR_TAG"
              continue
            fi
            
            # Check if PR is closed
            PR_STATE=$(gh pr view "$PR_NUM" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")
            
            if [ "$PR_STATE" = "CLOSED" ] || [ "$PR_STATE" = "MERGED" ]; then
              echo "PR #${PR_NUM} is ${PR_STATE}, cleaning up chart version ${VERSION_ID} with tags: ${ALL_TAGS}"
              
              if [ "$DRY_RUN" = "true" ]; then
                echo "[DRY RUN] Would delete version ${VERSION_ID}"
              else
                gh api \
                  --method DELETE \
                  -H "Accept: application/vnd.github+json" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  "/orgs/${OWNER}/packages/container/charts%2F${PACKAGE_NAME}/versions/${VERSION_ID}" \
                  && echo "Deleted version ${VERSION_ID}" \
                  || echo "Failed to delete version ${VERSION_ID}"
              fi
            else
              echo "PR #${PR_NUM} is ${PR_STATE}, keeping chart version ${VERSION_ID}"
            fi
          done
          
          echo "Helm chart cleanup complete."
          
          # Cleanup untagged Helm charts — protect digests referenced by tagged
          # chart versions (cosign signatures, OCI referrers, etc.)
          echo ""
          echo "Building protected digest set from tagged Helm chart manifests..."
          CHART_PROTECTED=$(mktemp)
          
          OCI_TOKEN=$(curl -sf \
            -u "token:${GH_TOKEN}" \
            "https://ghcr.io/token?service=ghcr.io&scope=repository:${OWNER,,}/charts/${PACKAGE_NAME}:pull" \
            | jq -r '.token') || true
          
          if [ -z "${OCI_TOKEN}" ] || [ "${OCI_TOKEN}" = "null" ]; then
            echo "WARNING: Could not obtain OCI token for Helm charts — skipping untagged cleanup."
          else
            TAGGED_CHART_DIGESTS=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/orgs/${OWNER}/packages/container/charts%2F${PACKAGE_NAME}/versions" \
              --paginate \
              --jq '.[] | select(.metadata.container.tags | length > 0) | .name' 2>/dev/null || echo "")
            
            for DIGEST in $TAGGED_CHART_DIGESTS; do
              MANIFEST=$(curl -sf \
                -H "Authorization: Bearer ${OCI_TOKEN}" \
                -H "Accept: application/vnd.oci.image.index.v1+json,application/vnd.docker.distribution.manifest.list.v2+json,application/vnd.oci.image.manifest.v1+json,application/vnd.docker.distribution.manifest.v2+json" \
                "https://ghcr.io/v2/${OWNER,,}/charts/${PACKAGE_NAME}/manifests/${DIGEST}" 2>/dev/null) || continue
              echo "$MANIFEST" | jq -r '(.manifests // [])[]?.digest // empty' >> "$CHART_PROTECTED" 2>/dev/null || true
              # Also protect config and layer digests
              echo "$MANIFEST" | jq -r '.config.digest // empty' >> "$CHART_PROTECTED" 2>/dev/null || true
              echo "$MANIFEST" | jq -r '(.layers // [])[]?.digest // empty' >> "$CHART_PROTECTED" 2>/dev/null || true
            done
            
            sort -u -o "$CHART_PROTECTED" "$CHART_PROTECTED"
            echo "Found $(wc -l < "$CHART_PROTECTED" | tr -d ' ') protected Helm chart digests"
            
            echo "Fetching untagged Helm charts..."
            UNTAGGED=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/orgs/${OWNER}/packages/container/charts%2F${PACKAGE_NAME}/versions" \
              --paginate \
              --jq '.[] | select(.metadata.container.tags | length == 0) | "\(.id) \(.name)"' 2>/dev/null || echo "")
            
            if [ -z "$UNTAGGED" ]; then
              echo "No untagged Helm charts found."
            else
              while read -r VERSION_ID VERSION_NAME; do
                [ -z "$VERSION_ID" ] && continue
                if grep -qF "$VERSION_NAME" "$CHART_PROTECTED" 2>/dev/null; then
                  echo "Keeping ${VERSION_NAME} (referenced by tagged chart)"
                else
                  echo "Deleting orphaned chart ${VERSION_NAME} (id: ${VERSION_ID})"
                  if [ "$DRY_RUN" = "true" ]; then
                    echo "[DRY RUN] Would delete untagged version ${VERSION_ID}"
                  else
                    gh api \
                      --method DELETE \
                      -H "Accept: application/vnd.github+json" \
                      -H "X-GitHub-Api-Version: 2022-11-28" \
                      "/orgs/${OWNER}/packages/container/charts%2F${PACKAGE_NAME}/versions/${VERSION_ID}" \
                      && echo "Deleted untagged version ${VERSION_ID}" \
                      || echo "Failed to delete untagged version ${VERSION_ID}"
                  fi
                fi
              done <<< "$UNTAGGED"
              echo "Untagged chart cleanup complete."
            fi
          fi
          
          rm -f "$CHART_PROTECTED"
